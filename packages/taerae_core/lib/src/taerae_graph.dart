import 'dart:collection';

import '_taerae_utils.dart';
import 'taerae_edge.dart';
import 'taerae_node.dart';

/// Lightweight in-memory graph engine.
class TaeraeGraph {
  /// Creates an empty graph.
  TaeraeGraph();

  /// Rebuilds a graph from JSON data generated by [toJson].
  factory TaeraeGraph.fromJson(Map<String, Object?> json) {
    final TaeraeGraph graph = TaeraeGraph();
    final Object? rawNodes = json['nodes'];
    final Object? rawEdges = json['edges'];

    if (rawNodes != null && rawNodes is! List<Object?>) {
      throw FormatException('Expected "nodes" to be a list.');
    }
    if (rawEdges != null && rawEdges is! List<Object?>) {
      throw FormatException('Expected "edges" to be a list.');
    }

    if (rawNodes is List<Object?>) {
      for (int index = 0; index < rawNodes.length; index++) {
        final TaeraeNode node = TaeraeNode.fromJson(
          readStringKeyedMap(rawNodes[index], 'nodes[$index]'),
        );
        graph.upsertNode(
          node.id,
          labels: node.labels,
          properties: node.properties,
        );
      }
    }

    if (rawEdges is List<Object?>) {
      for (int index = 0; index < rawEdges.length; index++) {
        final TaeraeEdge edge = TaeraeEdge.fromJson(
          readStringKeyedMap(rawEdges[index], 'edges[$index]'),
        );
        graph.upsertEdge(
          edge.id,
          edge.from,
          edge.to,
          type: edge.type,
          properties: edge.properties,
        );
      }
    }

    return graph;
  }

  final Map<String, TaeraeNode> _nodes = <String, TaeraeNode>{};
  final Map<String, TaeraeEdge> _edges = <String, TaeraeEdge>{};

  final Map<String, Set<String>> _outgoingEdgeIdsByNode =
      <String, Set<String>>{};
  final Map<String, Set<String>> _incomingEdgeIdsByNode =
      <String, Set<String>>{};

  final Map<String, Set<String>> _nodeIdsByLabel = <String, Set<String>>{};
  final Map<String, Map<_PropertyValueKey, Set<String>>> _nodeIdsByProperty =
      <String, Map<_PropertyValueKey, Set<String>>>{};

  /// Inserts a new node or updates an existing node by [id].
  ///
  /// If `labels` or `properties` are omitted for an existing node, the current
  /// values are retained.
  TaeraeNode upsertNode(
    String id, {
    Iterable<String>? labels,
    Map<String, Object?>? properties,
  }) {
    requireNonEmpty(id, 'id');

    final TaeraeNode? existingNode = _nodes[id];
    final TaeraeNode nextNode = TaeraeNode(
      id: id,
      labels: labels ?? existingNode?.labels ?? const <String>{},
      properties:
          properties ?? existingNode?.properties ?? const <String, Object?>{},
    );

    if (existingNode != null) {
      _removeNodeIndexes(existingNode);
    }

    _nodes[id] = nextNode;
    _addNodeIndexes(nextNode);
    _outgoingEdgeIdsByNode.putIfAbsent(id, () => <String>{});
    _incomingEdgeIdsByNode.putIfAbsent(id, () => <String>{});
    return nextNode;
  }

  /// Removes a node and all incident edges.
  ///
  /// Returns `true` when the node existed.
  bool removeNode(String id) {
    requireNonEmpty(id, 'id');

    final TaeraeNode? node = _nodes.remove(id);
    if (node == null) {
      return false;
    }

    _removeNodeIndexes(node);

    final Set<String> incidentEdgeIds = <String>{};
    final Set<String>? outgoing = _outgoingEdgeIdsByNode.remove(id);
    if (outgoing != null) {
      incidentEdgeIds.addAll(outgoing);
    }

    final Set<String>? incoming = _incomingEdgeIdsByNode.remove(id);
    if (incoming != null) {
      incidentEdgeIds.addAll(incoming);
    }

    for (final String edgeId in incidentEdgeIds) {
      _removeEdgeInternal(edgeId);
    }

    return true;
  }

  /// Inserts a new edge or updates an existing edge by [id].
  ///
  /// Both [from] and [to] must reference existing nodes.
  TaeraeEdge upsertEdge(
    String id,
    String from,
    String to, {
    String? type,
    Map<String, Object?>? properties,
  }) {
    requireNonEmpty(id, 'id');
    requireNonEmpty(from, 'from');
    requireNonEmpty(to, 'to');

    if (!_nodes.containsKey(from)) {
      throw StateError(
        'Cannot upsert edge "$id": source node "$from" does not exist.',
      );
    }
    if (!_nodes.containsKey(to)) {
      throw StateError(
        'Cannot upsert edge "$id": target node "$to" does not exist.',
      );
    }

    final TaeraeEdge? existingEdge = _edges[id];
    final TaeraeEdge nextEdge = TaeraeEdge(
      id: id,
      from: from,
      to: to,
      type: type ?? existingEdge?.type,
      properties:
          properties ?? existingEdge?.properties ?? const <String, Object?>{},
    );

    if (existingEdge != null) {
      _deindexEdge(existingEdge);
    }

    _edges[id] = nextEdge;
    _indexEdge(nextEdge);
    return nextEdge;
  }

  /// Removes an edge by [id].
  ///
  /// Returns `true` when the edge existed.
  bool removeEdge(String id) {
    requireNonEmpty(id, 'id');
    return _removeEdgeInternal(id) != null;
  }

  /// Whether a node with [id] exists.
  bool containsNode(String id) => _nodes.containsKey(id);

  /// Whether an edge with [id] exists.
  bool containsEdge(String id) => _edges.containsKey(id);

  /// Returns the node with [id] or `null`.
  TaeraeNode? nodeById(String id) => _nodes[id];

  /// Returns the edge with [id] or `null`.
  TaeraeEdge? edgeById(String id) => _edges[id];

  /// Returns outgoing edges for [nodeId], optionally filtered by [type].
  List<TaeraeEdge> outgoing(String nodeId, {String? type}) {
    return _collectEdges(_outgoingEdgeIdsByNode[nodeId], type: type);
  }

  /// Returns incoming edges for [nodeId], optionally filtered by [type].
  List<TaeraeEdge> incoming(String nodeId, {String? type}) {
    return _collectEdges(_incomingEdgeIdsByNode[nodeId], type: type);
  }

  /// Returns neighboring nodes for [nodeId], optionally filtered by [type].
  ///
  /// Set [bothDirections] to `false` to consider only outgoing edges.
  List<TaeraeNode> neighbors(
    String nodeId, {
    String? type,
    bool bothDirections = true,
  }) {
    if (!_nodes.containsKey(nodeId)) {
      return const <TaeraeNode>[];
    }

    final LinkedHashSet<String> neighborIds = LinkedHashSet<String>();

    for (final TaeraeEdge edge in outgoing(nodeId, type: type)) {
      neighborIds.add(edge.to);
    }
    if (bothDirections) {
      for (final TaeraeEdge edge in incoming(nodeId, type: type)) {
        neighborIds.add(edge.from);
      }
    }

    final List<TaeraeNode> neighbors = <TaeraeNode>[];
    for (final String id in neighborIds) {
      final TaeraeNode? neighbor = _nodes[id];
      if (neighbor != null) {
        neighbors.add(neighbor);
      }
    }

    return List<TaeraeNode>.unmodifiable(neighbors);
  }

  /// Returns nodes that contain [label].
  List<TaeraeNode> nodesByLabel(String label) {
    final Set<String>? nodeIds = _nodeIdsByLabel[label];
    if (nodeIds == null || nodeIds.isEmpty) {
      return const <TaeraeNode>[];
    }

    final List<TaeraeNode> result = <TaeraeNode>[];
    for (final String id in nodeIds) {
      final TaeraeNode? node = _nodes[id];
      if (node != null) {
        result.add(node);
      }
    }
    return List<TaeraeNode>.unmodifiable(result);
  }

  /// Returns nodes where property [key] matches [value].
  List<TaeraeNode> nodesWhereProperty(String key, Object? value) {
    final Map<_PropertyValueKey, Set<String>>? valueIndex =
        _nodeIdsByProperty[key];
    if (valueIndex == null) {
      return const <TaeraeNode>[];
    }

    final Set<String>? nodeIds = valueIndex[_PropertyValueKey(value)];
    if (nodeIds == null || nodeIds.isEmpty) {
      return const <TaeraeNode>[];
    }

    final List<TaeraeNode> result = <TaeraeNode>[];
    for (final String id in nodeIds) {
      final TaeraeNode? node = _nodes[id];
      if (node != null) {
        result.add(node);
      }
    }
    return List<TaeraeNode>.unmodifiable(result);
  }

  /// Finds the shortest directed path from [startId] to [endId] using BFS.
  ///
  /// Returns a list of node ids from start to end, or `null` if unreachable.
  /// When [edgeType] is provided only edges of that type are traversed.
  List<String>? shortestPathBfs(
    String startId,
    String endId, {
    String? edgeType,
  }) {
    requireNonEmpty(startId, 'startId');
    requireNonEmpty(endId, 'endId');

    if (!_nodes.containsKey(startId) || !_nodes.containsKey(endId)) {
      return null;
    }
    if (startId == endId) {
      return <String>[startId];
    }

    final Queue<String> queue = Queue<String>()..add(startId);
    final Map<String, String?> previous = <String, String?>{startId: null};

    while (queue.isNotEmpty) {
      final String current = queue.removeFirst();
      for (final TaeraeEdge edge in outgoing(current, type: edgeType)) {
        final String nextNodeId = edge.to;
        if (previous.containsKey(nextNodeId)) {
          continue;
        }

        previous[nextNodeId] = current;
        if (nextNodeId == endId) {
          return _reconstructPath(previous, endId);
        }

        queue.add(nextNodeId);
      }
    }

    return null;
  }

  /// Returns a deep copy of this graph.
  TaeraeGraph copy() {
    final TaeraeGraph clone = TaeraeGraph();

    for (final TaeraeNode node in _nodes.values) {
      clone._nodes[node.id] = node;
      clone._addNodeIndexes(node);
      clone._outgoingEdgeIdsByNode.putIfAbsent(node.id, () => <String>{});
      clone._incomingEdgeIdsByNode.putIfAbsent(node.id, () => <String>{});
    }

    for (final TaeraeEdge edge in _edges.values) {
      clone._edges[edge.id] = edge;
      clone._indexEdge(edge);
    }

    return clone;
  }

  /// Removes all nodes, edges, and indexes.
  void clear() {
    _nodes.clear();
    _edges.clear();
    _outgoingEdgeIdsByNode.clear();
    _incomingEdgeIdsByNode.clear();
    _nodeIdsByLabel.clear();
    _nodeIdsByProperty.clear();
  }

  /// Serializes the graph to JSON.
  Map<String, Object?> toJson() {
    final List<TaeraeNode> nodes = _nodes.values.toList(growable: true)
      ..sort((TaeraeNode a, TaeraeNode b) => a.id.compareTo(b.id));
    final List<TaeraeEdge> edges = _edges.values.toList(growable: true)
      ..sort((TaeraeEdge a, TaeraeEdge b) => a.id.compareTo(b.id));

    return <String, Object?>{
      'nodes': nodes.map((TaeraeNode node) => node.toJson()).toList(),
      'edges': edges.map((TaeraeEdge edge) => edge.toJson()).toList(),
    };
  }

  void _addNodeIndexes(TaeraeNode node) {
    for (final String label in node.labels) {
      _nodeIdsByLabel.putIfAbsent(label, () => <String>{}).add(node.id);
    }

    for (final MapEntry<String, Object?> entry in node.properties.entries) {
      final Map<_PropertyValueKey, Set<String>> valueIndex = _nodeIdsByProperty
          .putIfAbsent(entry.key, () => <_PropertyValueKey, Set<String>>{});
      valueIndex
          .putIfAbsent(_PropertyValueKey(entry.value), () => <String>{})
          .add(node.id);
    }
  }

  void _removeNodeIndexes(TaeraeNode node) {
    for (final String label in node.labels) {
      final Set<String>? nodeIds = _nodeIdsByLabel[label];
      if (nodeIds == null) {
        continue;
      }
      nodeIds.remove(node.id);
      if (nodeIds.isEmpty) {
        _nodeIdsByLabel.remove(label);
      }
    }

    for (final MapEntry<String, Object?> entry in node.properties.entries) {
      final Map<_PropertyValueKey, Set<String>>? valueIndex =
          _nodeIdsByProperty[entry.key];
      if (valueIndex == null) {
        continue;
      }

      final Set<String>? nodeIds = valueIndex[_PropertyValueKey(entry.value)];
      if (nodeIds == null) {
        continue;
      }

      nodeIds.remove(node.id);
      if (nodeIds.isEmpty) {
        valueIndex.remove(_PropertyValueKey(entry.value));
      }
      if (valueIndex.isEmpty) {
        _nodeIdsByProperty.remove(entry.key);
      }
    }
  }

  void _indexEdge(TaeraeEdge edge) {
    _outgoingEdgeIdsByNode
        .putIfAbsent(edge.from, () => <String>{})
        .add(edge.id);
    _incomingEdgeIdsByNode.putIfAbsent(edge.to, () => <String>{}).add(edge.id);
  }

  void _deindexEdge(TaeraeEdge edge) {
    final Set<String>? outgoing = _outgoingEdgeIdsByNode[edge.from];
    if (outgoing != null) {
      outgoing.remove(edge.id);
      if (outgoing.isEmpty && !_nodes.containsKey(edge.from)) {
        _outgoingEdgeIdsByNode.remove(edge.from);
      }
    }

    final Set<String>? incoming = _incomingEdgeIdsByNode[edge.to];
    if (incoming != null) {
      incoming.remove(edge.id);
      if (incoming.isEmpty && !_nodes.containsKey(edge.to)) {
        _incomingEdgeIdsByNode.remove(edge.to);
      }
    }
  }

  TaeraeEdge? _removeEdgeInternal(String id) {
    final TaeraeEdge? edge = _edges.remove(id);
    if (edge == null) {
      return null;
    }
    _deindexEdge(edge);
    return edge;
  }

  List<TaeraeEdge> _collectEdges(Set<String>? edgeIds, {String? type}) {
    if (edgeIds == null || edgeIds.isEmpty) {
      return const <TaeraeEdge>[];
    }

    final List<TaeraeEdge> result = <TaeraeEdge>[];
    for (final String edgeId in edgeIds) {
      final TaeraeEdge? edge = _edges[edgeId];
      if (edge == null) {
        continue;
      }
      if (type != null && edge.type != type) {
        continue;
      }
      result.add(edge);
    }
    return List<TaeraeEdge>.unmodifiable(result);
  }

  List<String> _reconstructPath(
    Map<String, String?> previous,
    String endNodeId,
  ) {
    final List<String> path = <String>[];
    String? cursor = endNodeId;

    while (cursor != null) {
      path.add(cursor);
      cursor = previous[cursor];
    }

    return List<String>.unmodifiable(path.reversed);
  }
}

class _PropertyValueKey {
  const _PropertyValueKey(this.value);

  final Object? value;

  @override
  bool operator ==(Object other) {
    return other is _PropertyValueKey && _deepEquals(value, other.value);
  }

  @override
  int get hashCode => _deepHash(value);

  static bool _deepEquals(Object? left, Object? right) {
    if (identical(left, right)) {
      return true;
    }
    if (left is List<Object?> && right is List<Object?>) {
      if (left.length != right.length) {
        return false;
      }
      for (int i = 0; i < left.length; i++) {
        if (!_deepEquals(left[i], right[i])) {
          return false;
        }
      }
      return true;
    }
    if (left is Map<Object?, Object?> && right is Map<Object?, Object?>) {
      if (left.length != right.length) {
        return false;
      }

      for (final MapEntry<Object?, Object?> entry in left.entries) {
        if (!right.containsKey(entry.key)) {
          return false;
        }
        if (!_deepEquals(entry.value, right[entry.key])) {
          return false;
        }
      }
      return true;
    }

    return left == right;
  }

  static int _deepHash(Object? value) {
    if (value is List<Object?>) {
      return Object.hashAll(value.map(_deepHash));
    }
    if (value is Map<Object?, Object?>) {
      return Object.hashAllUnordered(
        value.entries.map(
          (MapEntry<Object?, Object?> entry) =>
              Object.hash(_deepHash(entry.key), _deepHash(entry.value)),
        ),
      );
    }
    return value.hashCode;
  }
}
